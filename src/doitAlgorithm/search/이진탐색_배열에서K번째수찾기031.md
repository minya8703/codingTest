## 배열에서 K번째 수 찾기
https://www.acmicpc.net/problem/1300

-----
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다.  
이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.

-----
#### 입력
- 1번째 줄에 배열의 크기 N이 주어진다. N은 ![img_21.png](img_21.png)보다 작거나 같은 자연수이다. 
- 2번째 줄에 k가 주어진다. k는 min(![img_22.png](img_22.png), ![img_23.png](img_23.png))보다 작거나 같은 자연수이다.


#### 출력
- B[k]를 출력

##### 예제
| 예제 번호 | 예제 입력    | 예제 출력 |
|:------|:---------|-------|
| 1     | 3 <br> 7 | 6     |


-----
### 슈도 코드
  ```
N(배열의 크기) K(구하고자 하는 index)
start(시작 인덱스 = 1)
end(종료 인덱스 = K)
while(시작 인덱스 <= 종료 인덱스){// 이진 탐색 수행하기
    middle(중간 인덱스)
    cnt(중앙값보다 작은 수)
    // 중앙값보다 작은 수는 몇 개인지 계산하기
    for(N의 개수만큼 반복하기){
       cnt에 중앙 인덱스를 i로 나눈 값과 N중 작은 값을 더함
    }
    if(cnt < K : 현재 중앙값보다 작은 수의 개수가 K보다 작음)
        시작 인덱스 = 중앙 인덱스 + 1
    else(현재 중앙값보다 작으 수의 개수가 K보다 크거나 같음)
        종료 인덱스 = 중앙 인덱스 + 1
        정답 변수에 중앙값 저장
}
정답 출력
  ```
-----
### 중요한 점
- k의 범위가 1~minmin(![img_22.png](img_22.png), ![img_23.png](img_23.png))이므로 시간 복잡도가 ![img_23.png](img_23.png)인 알고리즘은 사용할 수 없다
- 이진탐색으로 중앙값보다 작은 수의 개수를 세면서 범위를 절반씩 줄이는 방법으로 B[k]값을 구한다.  
- 다시 말해 작은 수의 개수가 k-1개인 중앙값이 정답.(작은 수 개수를 세는 아이디어)
![img_24.png](img_24.png)
2차원 배열은 N행이 N의 배수로 구성되어 있으므로 2차원 배열에서의 k번째 수는 k를 넘지 않습니다.
- 다시말해 2차원 배열의 1~k번째 안에 정답이 있습니다. 이점에 주목하여 이진 탐색의 시작 인덱스를 1, 종료 인덱스를 k로 정합니다.
- 다음은 N =3, k=7일 때를 예로 든 것입니다.  
  `이진 탐색 조건`  
      - 중앙값 크기보다 작은 수가 K보다 작으면 시작 인덱스 = 중앙값 + 1  
      - 중앙값 크기보다 작은 수가 K보다 크거나 같으면 종료 인덱스 = 중앙값 -1, 정답 변수 = 중앙값